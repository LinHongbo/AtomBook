# 深入理解Java虚拟机--JVM高级特性与最佳实现
## 第3章 垃圾收集器与内存分配策略
### 3.1 概述
垃圾收集（Garbage Collection, GC）需要完成的 3 件事情：
* 那些内存需要回收
* 什么时候回收
* 如何回收
### 3.2 对象已死吗
#### 3.2.1 引用计数算法
主流的 Java 虚拟机里面并没有选用引用计数算法来管理内存，其中最主要的原因是它很难解决对象之间相互循环引用的问题。
#### 3.2.2 可达性分析算法
在 Java 语言中，可以作为 GC Root 的对象包括以下几种：
* 虚拟机栈（栈帧中的本地变量表）中引用的对象
* 方法区中类静态属性引用的对象
* 方法区中常量引用的对象
* 本地方法栈中 JNI (即一般说的 Native 方法) 引用的对象

#### 3.2.3 再谈引用
* **强引用**
* **软引用**：对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列入回收范围之中进行第二次回收，如果这次回收还没有足够的内存，才会抛出内存溢出异常。
* **弱引用**：被弱引用关联的对象只能生存在下一次垃圾收集之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。
* **虚引用**：一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象的实力。**为一个对象设置虚引用关联的唯一目的，就是能在这个对象被收集器回收时收到一个系统通知。**
#### 3.2.4 生存还是死亡
finalize()：只会被系统调用一次。
```
if( 重写了finalize() && finalize() 没被执行过 ){
    通知 GC x秒后执行内存回收;
    finalize();

    x 秒后
    if( 对象没被引用 ){
        GC 回收内存;
    }
}
GC 回收内存;
```
#### 3.2.5 回收方法区
方法区的垃圾收集主要回收两部分的内容：废弃常量和无用的类。  
废弃常量的收集与堆的收集类似。  
判断类是否是“无用的类”，需要满足以下3个条件：
* 该类的所有实例已经被回收，也就是堆中不存在该类的任何实例。
* 加载该类的 ClassLoader 已经被回收。
* 该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。  
注：**虚拟机可以对满足上述 3 个条件的无用类进行回收，这里说的仅仅是“可以”，而不是和对象一样，不使用了就必然会被回收**
### 3.3 垃圾收集算法
#### 3.3.1 标记 - 清除算法
之所以说它时最基础的收集算法，是因为后续的收集算法都是基于这种思路，并对其不足进行改进而得到的。它的不足有两个：
* 效率。标记和清除两个过程的效率都不高；
* 空间碎片过多。可能会导致以后在程序运行过程中需要分配较大的对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。
#### 3.3.2 复制算法
* 效率较高
* 浪费50%的内存空间
#### 3.3.3 标记 - 整理算法
#### 3.3.4 分代收集算法
* 新生代：复制算法
* 老年代：标记 - 清除算法或者标记 - 整理算法
### 3.4  HotSpot 的算法实现
#### 3.4.1 枚举根节点
* 使用 OopMap 数据结构，快速遍历根节点引用。
* 进行 GC 分析工作，需要在一个能确保一致性的快照中进行。
#### 3.4.2 安全点（Safepoint）
* 如何进入 GC：每条线程进入安全点
* 使用 OopMap 进行 GC Roots 遍历所带来的问题
* 安全点的选择
* 抢占式中断（Preemptive Suspension）
* 主动式中断（Voluntary Suspension）
#### 3.4.3 安全区域（Safe Region）
* 扩展的安全点。
* 针对没有分配 CPU 资源的程序，比如 sleep()/Blocked 提出的。
* 离开 Safe Region 需要等待整个 GC 完成才可以继续执行。
### 3.5 垃圾收集器
#### 3.5.1 Serial 收集器
Client 模式下，默认的新生代收集器。
* 使用复制算法
* 简单而高效：单 CPU 情况下，Serial 收集器没有线程交互的开销
* 在 Client 端，新生代容量较小，即使停顿，也可以控制在几十 ms 至 100 ms内，不影响体验。
#### 3.5.2 ParNew 收集器
* 多线程版本的 Serial 收集器。
* Server 模式下，首选的新生代收集器，因为只有它（还有 Serial ）能跟 CMS 配合使用。
* 单核情况下，性能没有 Serial 收集器高。
* 双核情况下，也不一定比 Serial 收集器有更高的性能，但核越多，ParNew 的优势就越明显
* 默认开启的收集线程数与 CPU 的数量相同，但也可以进行 GC 线程数量的限制。
#### 3.5.3 Parallel Scavenger 收集器
* 使用复制算法
* 多线程
* Parallel Scavenger 收集器的目标是达到一个可控制的吞吐量（吞吐量 = 运行用户代码时间/(运行用户代码时间 + 垃圾收集时间)）
* 停顿时间越短，适合需要与用户交互的程序；高吞吐量则可以高效率利用 CPU 时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。
* GC 自适应调节策略（GC Ergonomics）
#### 3.5.4 Serial Old 收集器
* 单线程
* 使用标记 - 整理算法
* 默认 Client 端的老年代收集器
* Server 端如果使用 Serial Old 收集器，要么是为了在1.5 及之前版本中与 Parallel Scavenger 收集器搭配使用，要么作为 CMS 收集器的后预备案。
#### 3.5.5 Parallel Old 收集器
* 多线程
* 使用标记 - 整理算法
* JDK 1.6 后开始提供
#### 3.5.6 CMS 收集器（Concurrent Mark Sweep）
* 获取最短回收停顿时间为目标
* 使用标记 - 清除算法（初始标记、并发标记、重新标记、并发清除/ CMS initial mark、CMS concurrent mark、CMS remark、CMS concurrent sweep）
* 初始标记、重新标记这两个步骤，仍然需要“stop the world”
>* CMS 收集器对 CPU 资源非常敏感，其实，面向并发设计的程序都对 CPU 资源敏感。在并发阶段，它虽然不会导致用户线程停顿，但是会因为占用一部分 CPU 资源而导致应用程序变慢，总吞吐量降低。当在低 CPU 的机器上，采用 GC 线程与用户线程交替运行的方式，这样会让这个收集过程变长，但对用户程序的影响就会显得更小一些。
>* CMS 收集器无法处理浮动垃圾（Floating Garbage），可能出现“Concurrent Mode Failure”失败而导致另一次 Full GC 的产生。此外，预留的内存不足也会导致“Concurrent Mode Failure”，此时一般会采用Serial Old 来重新进行老年代的收集。
>* 标记 - 清除算法的缺点。
#### 3.5.7 G1 收集器（Garbage First）
* 面向服务器端应用的垃圾收集器
* 有点复杂，需要时再看吧
#### 3.5.8 理解 GC 日志
#### 3.5.9 垃圾收集器参数总结
### 3.6 内存分配与回收策略
#### 3.6.1 对象优先在 Eden 分配
* 新生代 GC (Minor GC)
* 老年代 GC (Major GC / Full GC)
#### 3.6.2 大对象直接进入老年代
#### 3.6.3 长期存活的对象将进入老年代
#### 3.6.4 动态判断年龄对象
如果在 Survivor 空间中相同年龄所有对象大小的总和大于 Survivor 空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代。
#### 3.6.5 空间分配担保
