# Shell脚本学习指南
## 第1章 背景知识
### 1.1 UNIX简史
### 1.2 软件工具的原则
* **一次做好一件事**：不断生产出更小、更专用于特定功能的程序，就像专业木匠的工具箱里，永远会有一堆专为特定用途所设计的工具。
* 处理文本行，不处理二进制数据：文本行是UNIX的通用格式。当你在编写自己的工具程序时便会发现，内涵文本行的数据文件很好处理，你可以用任何唾手可得的文本编辑器来编辑它，也可以让这些数据在网络与各种机器架构之间传输。使用文本文件更有助于任何自定义工具与现存UNIX程序之间的结合。
> 我的理解是：同一段文本行，在不同的编码下，二进制数据是不一样的，那么处理起来就会比较麻烦。
* **使用正则表达式**：正则表达式是很强的文本处理机制。了解它的运作模式并加以使用，可适度简化编写命令脚本的工作。
> 虽然正则表达式多年来在工具与UNIX版本上不断在变化，但POSIX标准仅提供两种正则表达式。你可以利用标准的库程序进行模式匹配的工作。这样就可以编写出专用的工具程序，用于与grep一致的正则表达式（POSIX称之为基本型正则表达式，Basic Regular Expressions, BRE），或是用于与egrep一致的正则表达式（POSIX称之为扩展型正则表达式，Extended Regular Expressions, ERE）
* **默认使用标准输入/输出**：在未明确指定文件名的情况下，程序默认会从它的标准输入读取数据，将数据写到它的标准输出，至于错误信息则会传送到标准错误输出。以这样的方式来编写程序，可以轻松地让他们成为数据过滤器，例如，组成部分的规模越大，越需要复杂的管道（pipeline）或脚本来处理。
* **避免喋喋不休**：软件工具的执行过程中不该像在“聊天”。不要将“开始处理”、“即将完成”或是“处理完成”这类信息放进程序的标准输出（至少这不该是默认状态）。
> 在工具程序的世界里，没有消息就是好消息。
* **输出格式必须与可接受的输入格式一致**：专业的工具程序认为遵循某种格式的的输入数据，例如在标题行之后接着数据行，或在行上使用某种字段分隔符等，所产生的输出也应遵循与输入一致的规则。这么做的好处是，容易将一个程序的执行结果交给另外一个程序处理。
* **让工具去做困难的部分**
* **构建特定工具前，先想想**
### 1.3 小结
## 第2章 入门
### 2.1 脚本编程语言与编译编译型语言的差异
* **编译型语言**：从源代码（source code）转换成目标代码（object code），便能直接通过计算机来执行。
> 编译型语言的好处是高效，缺点则是：它们多半运作于底层，所处理的是字节、整数、浮点数或是其他机器层级的对象。例如，在C++里，就很难进行“将一个目录里的所有文件复制到另外一个目录中”之类的操作。
* **解释型语言**：由解释器（interrupter）读入程序代码，并将其转换成内部的形式，再执行。
> 解释器本身是一般的编译型程序。
### 2.2 为什么要使用Shell脚本
* 好处：他们多半运行在比编译性语言还高的层次，能够轻易处理文本与目录之类的对象。  
* 缺点：它们的效率通常不如编译型语言。

权衡之下，通常使用脚本编程还是值得的：
* 花一小时编写的简单脚本，同样的功能用C或C++来编写实现，可能需要两天。
* 一般来说，脚本的执行速度已经够快了，快到足以让人忽略其性能上的问题。  
* Shell是各UNIX系统的通用功能，并且经过了POSIX的标准化，因此，Shell脚本只要“用心写”一次，即可应用到很多系统上。

因此，之所以要使用Shell脚本是基于：
* 简单性：Shell是一个高级语言，通过它，你可以简洁地表达复杂的操作
* 可移植性：使用POSIX所定义的功能，可以做到脚本无需修改就可以在不同的系统上执行
* 开发容易：可以在短时间内完成一个功能强大又好用的脚本
### 2.3 一个简单的脚本
`who | wc -l/w/c`
### 2.4 自给自足的脚本：位于第一行的#！
当Shell执行一个程序时，会要求UNIX内核启动一个新的进程，以便在该进程里执行所指定的程序。内核知道如何为编译型程序做这件事。但是Shell脚本并非编译型程序，当Shell要求内核执行它时，内核将无法做这件事，并回应“not executeable format file”（不是可执行的格式文件）错误信息。Shell收到此错误信息时，就会说“啊哈，这不是编译型程序，那么一定是Shell脚本”，接着会启动一个新的/bin/sh（标准Shell）副本来执行改程序。

当系统只有一个Shell时，“退回到/bin/sh”的机制非常方便。但现行的UNIX系统都会拥有好几个Shell，因此需要通过一种方式，告知UNIX内核应该以哪个Shell来执行所指定的Shell脚本。事实上，这么做有助于执行机制的通用化，让用户得以直接引用任何的程序语言解释器，而非只是一个命令Shell。

POSIX标准对#！的行为模式保留未定义（unspecified）状态,此状态是“只要一直保持POSIX兼容性，这是一个扩展功能”的标准说法。
```
#! /bin/sh -
# 选项-表示没有Shell选项，这是基于安全上的考虑，可避免某种程度的欺骗式攻击
who | wc -l
```
### 2.5 Shell的基本元素
#### 2.5.1 命令与参数
Shell 识别三种基本命令：内建命令、Shell函数以及外部命令
* **内建命令**就是由Shell本身锁执行的命令。有些命令是由于其必要性才内建的，例如cd、read等。另一种内建命令的存在则是为了效率，其中最典型的就是test命令、IO命令（echo、printf）。
* **Shell函数**是功能健全的一系列程序代码，以Shell语言携程，它们可以像命令那样引用。
* **外部命令**就是由一个Shell副本（新的进程）所执行的命令，基本的过程如下：
> a.建立一个新的进程，次进程即为Shell的一个副本。  
> b.在新的进程里，在PATH变量内所列出的目录中，寻找特定的命令。  
> c.在新的进程里，以所找到的新程序取代执行中的Shell程序并执行。  
> d.程序完成后，最初的Shell会接着从终端读取下一条命令，或执行脚本里的下一条命令。
#### 2.5.2 变量
一般情况下，引用变量可以不带双引号，但是如果需要进行变量之间的拼接，那么就需要使用双引号了（类似java字符串的 + ）。
#### 2.5.3 简单的echo输出
* BSD版本：-n,表示忽略结尾的换行符号。
* UNIX各版本间互不相同的行为模式使得echo的可移植性变得很困难，不过它仍然是最简单的一种输出方式。
* echo的转义序列

序列|说明  
---|---
\a|警示字符，通常是ASCII的BEL字符
\b|退格（Backspace）
\c|输出中忽略最后的换行字符（Newline）。这个参数之后的任何字符，包括接下来的参数，都会被忽略掉（不打印）
\f|清除屏幕（Formfeed）
\n|换行（Newline）
\r|回车（Carriage return）
\t|水平制表符（Horizontal tab）
\v|垂直制表符（Vertical tab）
\\|反斜杠字符
\0ddd|将字符表示成八进制数值
#### 2.5.4 华丽的 printf 输出
跟C的printf()函数类似。
#### 2.5.5 基本的 I/O 重定向
登录时，UNIX便将默认的标准输入、输出以及错误输出安排成终端。I/O重定向就是通过与终端交互或者在Shell脚本里设置，重新安排从哪里输入或者输出到哪里。
* 标准输入：一般是键盘
* 标准输出：一般是屏幕
* 标准输出：一般是屏幕
##### 2.5.5.1 重定向与管道
* 以 < 改变标准输入
* 以 > 改变标准输出：覆盖目标文件
* 以 >> 附加到文件
* 以 | 建立管道：虽然 < 和 > 可将输入与输出连接到文件，不过管道（pipeline）可以吧两个以上的执行中的程序链接在一起，第一个程序的标准输出可以变成第二个程序的标准输入。这么做的好处是，管道可以使得执行速度比使用临时文件的程序快上十倍。
```
tr [ options ] source-char-list replace-char-list
用途：转换字符、删除、压缩字符
optoin:
    -c 取source-char-list的反义。tr要转换的字符，变成未列在source-char-list中的字符。此选项通常与 -d 或 -s 配合使用。
    -C 与 -c 相似，但所处理的是字符（可能是包含多个字节的宽字符），而非二进制的字节值。
    -d 自标准输入删除 source-char-list 里所列的字符，而不是转换它们。
    -s 浓缩重复的字符。
* 注意：处理的是字符，而非字符串。
```
##### 2.5.5.2 特殊文件：/dev/null 与 /dev/tty
UNIX系统提供了两个队Shell编程特别有用的特殊文件。第一个文件 /dev/null，也就是大家所熟知的位桶（bit bucket），传送到此文件的数据都会被系统丢掉。

另外一个特殊文件为 /dev/tty。当程序打开此文件时，UNIX会自动将它重定向到一个终端再与程序结合。这在程序必须读取人工输入时特别有用。此外用它来产生错误信息也很方便，只是比较少人这么做。
```
printf "Enter new password: "
stty -echo
read pass < /dev/tty
printf "Enter again: "
read pass2 < /dev/tty
stty echo
```
#### 2.5.6 基本命令查找
讲PATH环境变量
### 2.6 访问 Shell 脚本的参数
$1、$2、$3、$4、$5、$6、$7、$8、$9  
${10}、${11}、${12}、${13}、${14}、${15}、${16}、${17}、${18}、${19}
### 2.7 简单的执行跟踪
* set -x：打开跟踪
* set +x：关闭跟踪
### 2.8 国际化与本地化
各种Locale环境变量
名称|说明
---|---
LANG|未设置任何LC_XXX变量时所使用的默认值
LC_ALL|用来覆盖掉所有其他LC_XXX变量的值
LC_COLLATE|使用所指定地区的排序规则
LC_CTYPE|使用所指定地区的字符集（字母、数字、标点符号等）
LC_MESSAGES|使用所指定地区的响应与信息，仅 POSIX 使用
LC_MONETARY|使用所指定地区的货币格式
LC_NUMERIC|使用所指定地区的数字格式
LC_TIME|使用所指定地区的日期与时间格式
### 2.9 小结
## 第3章 查找与替换
### 3.1 查找文本
介绍了grep、egrep、fgrep。
#### 3.1.1 简单的grep
### 3.2 正则表达式
```
grep [ option ] pattern-spec [ files ]
option:
    -E 使用扩展正则表达式进行匹配。grep -E 可取代传统的egrep。
    -F 使用固定字符串进行匹配。grep -F 可取代传统的fgrep。
    -e pat-list 通常，第一个非选项参数会指定要匹配的模式。你也可以提供多个模式，只要将它们放在引号里并以换行字符分隔它们。
    模式以减号开头时，grep会混淆，而将它们视为选项。这就是-e选项派上用场的时候，它可以指定其参数为模式----即使它以减号开头。
    -f pat-file 从pat-file文件读取模式作为匹配。
    -i 模糊匹配时忽略字母大小写差异。
    -l 列出匹配模式的文件名称，而不是打印匹配的行
    -q 静默地。如果模式匹配成功，则grep会成功地离开，而不将匹配的行写入标准输出，否则即是不成功。
    -s 不显示错误信息，通常与 -q 并用
    -v 显示不匹配模式的行。
```
#### 3.2.1 什么是正则表达式
##### 3.2.1.1 POSIX 方括号表达式
* 字符集
> 以[ : 与 ：]将关键字组合括起来的POSIX字符集。关键字描述各种不同的字符集，例如英文字母字符、控制字符等。

* 排序符号
> 排序符号指的是将多字符序列视为一个单位。它使用[ . 与 .]将字符组合括起来。排序符号在系统所使用的特定locale上各有其定义。
* 等价字符集
> 等价字符集列出的是应视为等值的一组字符，它由取自于locale的名字元素组成，以[ = 与 =]括住。

POSIX字符集
类别|匹配字符|类别|匹配字符
---|---|---|---
[ : alnum : ]|数字字符|[ : lower : ]|小写字母字符
[ : alpha : ]|字母字符|[ : print : ]|可显示的字符
[ : blank : ]|space、tab|[ : punct : ]|标点符号字符
[ : cntrl : ]|控制字符|[ : space : ]|空白字符
[ : digit : ]|数字字符|[ : upper : ]|大写字母字符
[ : graph : ]|nonspace字符|[ : xdigit : ]|十六进制数字
#### 3.2.2 基本正则表达式
##### 3.2.2.1 匹配单个字符
注意：
* 排序元素、等价字符集以及字符集，都仅在方括号表达式的方括号内认可，也就是说，向[ : alpha : ]这样的正则表达式，匹配字符为a、l、p、h以及：，表示所有英文字母的正确写法应该是[ [ : alpha : ] ]。
* 在方括号表达式中，所有其他的meta字符都会失去其特殊含义。要让 ] 进入该集合，可以将它放在列表的最前面：[]\*\\.]。要让减号字符进入该集合，也请将它放到列表最前端：[-\*\\.]。若你需要右方括号与减号两者进入列表，请将右方括号放到第一个字符、减号放到最后一个字符：[]\*\\.-]。
##### 3.2.2.2 后向引用
BRE提供一种叫后向引用的机制，指的是“匹配于正则表达式匹配的先前的部分”。使用后向引用的步骤有两个。第一步是将子表达式包围在 \\( 与 \\) 里（单个模式里可包括至多9个子表达式，且可为嵌套结构）。下一步是在同一模式之后使用\digit，digit 指的是介于1-9的数字，指的是“匹配于第 n 个先前方括号内子表达式匹配成功的字符”。
> **后向引用在寻找重复字以及匹配引号时特别好用。**
##### 3.2.2.3 单个表达式匹配多字符
##### 3.2.2.4 文本匹配锚点
##### 3.2.2.5 BRE运算符优先级
BRE运算符优先级，由高至低
运算符|表示意义
---|---
[..] [==] [::]|用于字符排序的方括号符号
\metacharacter|转义的meta字符
[]|方括号表达式
\\( \\) \\digit|子表达式与后向引用
\*   \\{digit\\}|前置单个字符重现的正则表达式
无符号|连续
^   $|锚点
#### 3.2.3 扩展正则表达式
##### 3.2.3.1 匹配单个字符
在匹配单个字符的情况下，ERE本质上是与BRE是一致的。特别是像一般字符，用以转义meta字符的反斜杠，以及方括号表达式，这些行为模式斗鱼先前提及的BRE相同。较有名的一个例外出现在awk里：其\符号在方括号表达式内表示其他的含义。因此，如需匹配左方括号、连字符、右方括号或是反斜杠，你应该用[\\[ \\- \\] \\\\ ]，这是使用上的经验法则。
##### 3.2.3.2 后向引用不存在
##### 3.2.3.3 匹配单个表达式与多个正则表达式
我平时用的就是egrep
##### 3.2.3.4 交替
|
##### 3.2.3.5 分组
()
##### 3.2.3.6 停驻文本匹配
^   $
##### 3.2.3.7 ERE运算符的优先级
运算符|含义
---|---
[ : : ][ = = ][ . . ]|用于字符对应的方括号符号
\metacharacter|转义的meta字符
[]|方括号表达式
()|分组
\* + ? {}|重复前置的正则表达式
无符号|连续字符
^   $|锚点
\| |交替
#### 3.2.4 正则表达式的扩展
运算符|含义
---|---
\<、\>|单词头、单词尾
\w|匹配任何单词组成的字符，相当于[[:alnum:]_]
\W|匹配任何非单词组成的字符，相当于[\^[:alnum:]_]
\b|匹配单词的起始或结尾处所找到的空字符串
\B|匹配两个单子组成字符之间的空字符串
\\'  \\`|分别匹配emacs缓冲区的开始与结尾。GNU程序（还有emacs）通常将它们视为与^、$同义
#### 3.2.5 程序与正则表达式
#### 3.2.6 在文本文件里进行替换
sed
#### 3.2.7 基本用法
```
sed [ -n ] ‘editing command’ [ file ... ]
sed [ -n ] -e 'editing command' [ file ... ]
sed [ -n ] -f script-file ... [ file ... ]
option:
    -e 'editing command'
        将editing command使用在输入数据上。当有多个命令需应用时，就必须使用-e了
    -f script-file
        自script-file中读取编辑命令。当有多个命令需要执行时，此选项相当有用。
    -n 不是每个最后已修改结果都正常打印，而是显示以p指定（处理过的）行。
```
##### 3.2.7.1 替换细节
* 允许使用BRE的后向引用
* & 在替代文本里表示的意思是“从此点开始替代成匹配于正则表达式的整个文本”
* 使用sed注意要先备份
* 在 s 命令里以 g 结尾表示全局性（global）,如果没有设置 g，sed只会取代第一个匹配的。
* 在 s 命令里以数字 n 结尾，跟以 g 结尾类似，表示第 n 次匹配时替换。
* 在命令行上，可以通过 -e 选项的方式来完成多个文本的替换
```
sed -e 's/foo/bar/g' -e 's/chicken/cow/g' myfile.xml > myfile2.xml
```
#### 3.2.8 sed 的运作
每次读一行
##### 3.2.8.1 打印与否
-n 表示改变sed的默认行为。
```
# 仅显示HTML一行
sed -n '/<HTML>/p' *.html
```
#### 3.2.9 匹配特定行
```
address command
```
以下为不同类型的地址
* 正则表达式
```
# 注释部分源代码
sed '/oldfunc/ s/$/# xxx: migrate to newfunc/'

sed '/Tolstoy/ s//& and Camis/g'
```
* 最终行
```
# 引号里为指定显示的数据
sed -n '$p' "$1"
```
* 行编号
* 范围
```
sed -n '10,42p' foo.xml
# 该命令匹配到所有的行，再进行替换，而不是先匹配/foo/行，替换，再匹配/bar/行，再替换。
sed '/foo/,/bar/ s/baz/quux/g'
```
* 否定正则表达式
```
# 将没有used的每个行里所有的 new 改成 used
sed '/used/ !s/new/used/g'
```
#### 3.2.10 有多少文本会变动
正则表达式匹配可以匹配整个表达式的输入文本中**最长**的、**最左边**的子字符串。
```
echo Tolstoy is worldly | sed 's/T.*y/Camus/'
Camus

echo Tolstoy is worldly | sed 's/T[[:alpha:]]*y/Camus/'
Camus is worldly

echo abd | sed 's/b*/1/g'
1a1c1
```
#### 3.2.11 行 VS 字符串
字符串可以表示一行，也可以表示多行，这依赖程序程序语言关于定界符的规定。
grep、egrep、sed处理的行是独立的一个字符串，使用^、$作为定界符。
awk、Perl以及Python，所处理的是字符串，也就是这个字符串里面可能有好几行，如果只有一行的情况下，那么使用^、$作为行的定界符。
### 3.3 字段处理
#### 3.3.1 文本文件惯例
本小结对比了使用whitespace作为界定符与特定的定界符的优劣。
#### 3.3.2 使用cut选定字段
```
cut -c list [ file ... ]
cut -f list [ -d delim ] [ file ... ]
options:
    -c list 以字符为主，执行剪下的操作。list为字符编号或一段范围的列表（以逗号隔开），例如1，3，5-12，42。
    -d delim 通过 -f 选项，使用delim作为定界符。默认的定界符为tab。
    -f list 以字段为主，作剪下的操作。
```
#### 3.3.3 使用join连接字段
```
join [ options ... ] file1 file2
options:
    -1 field1
    -2 field2 标明要结合的字段。
    -o file.field 输出file文件中的field字段。
    -t separator 使用separator作为输入/输出字段分割字符，而非使用空白。
警告：
    -1 与-2 选项的用法是较新的，在较旧的系统上，可能得用：-j1 与 -j2 。
```
#### 3.3.4 使用awk重新编排字段
##### 3.3.4.1 模式与操作
```
awk 'program' [ file ... ]
pattern { action }
```
##### 3.3.4.2 字段
awk设计的重点就在字段与记录上：awk读取输入记录（通常是一些行）。然后自动将各个记录切分为字段。
```
# 打印第1个字段
awk '{ print $1 }'
# 打印第2与第5个字段
awk '{ print $2, $5}'
# 打印第1个与最后1个字段
awk '{ print $1, $NF }'
# 打印非空行,编号0表示整条记录
awk 'NF > 0 { print $0 }'
awk 'NF > 0'
```
##### 3.3.4.3 设置字段分割字符
```
awk -F: '{ print $1, $5 }' /etc/passwd
awk -F: -v 'OFS=**' '{ print $1, $5 }' /etc/passwd
```
##### 3.3.4.4 打印行
```
awk -F: '{print "User", $1, "is really", $5}' /etc/passwd
awk -F: '{printf "User %s is really %s\n", $1, $5}' /etc/passwd
```
##### 3.3.4.5 起始与清除
```
BEGIN { startup code }
pattern1 { action1 }
pattern2 { action2 }
END { cleanup code }
```
### 3.4 小结
## 第4章 文本处理工具
